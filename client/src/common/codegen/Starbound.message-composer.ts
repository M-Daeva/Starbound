/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.24.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { Coin } from "@cosmjs/amino";
import { MsgExecuteContractEncodeObject } from "cosmwasm";
import { MsgExecuteContract } from "cosmjs-types/cosmwasm/wasm/v1/tx";
import { toUtf8 } from "@cosmjs/encoding";
import { InstantiateMsg, ExecuteMsg, Uint128, Addr, Decimal, Timestamp, Uint64, User, Asset, PoolExtracted, UserExtracted, AssetExtracted, TransferParams, QueryMsg, MigrateMsg, QueryConfigResponse, Config, QueryLedgerResponse, Ledger, QueryPoolsAndUsersResponse, QueryUserResponse } from "./Starbound.types";
export interface StarboundMessage {
  contractAddress: string;
  sender: string;
  deposit: ({
    user
  }: {
    user: User;
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
  withdraw: ({
    amount
  }: {
    amount: Uint128;
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
  updateConfig: ({
    dappAddressAndDenomList,
    feeDefault,
    feeOsmo,
    scheduler,
    stablecoinDenom,
    stablecoinPoolId
  }: {
    dappAddressAndDenomList?: string[][][];
    feeDefault?: Decimal;
    feeOsmo?: Decimal;
    scheduler?: string;
    stablecoinDenom?: string;
    stablecoinPoolId?: number;
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
  updatePoolsAndUsers: ({
    pools,
    users
  }: {
    pools: PoolExtracted[];
    users: UserExtracted[];
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
  swap: (funds?: Coin[]) => MsgExecuteContractEncodeObject;
  transfer: (funds?: Coin[]) => MsgExecuteContractEncodeObject;
  multiTransfer: ({
    params
  }: {
    params: TransferParams[];
  }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
}
export class StarboundMessageComposer implements StarboundMessage {
  sender: string;
  contractAddress: string;

  constructor(sender: string, contractAddress: string) {
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.deposit = this.deposit.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.updatePoolsAndUsers = this.updatePoolsAndUsers.bind(this);
    this.swap = this.swap.bind(this);
    this.transfer = this.transfer.bind(this);
    this.multiTransfer = this.multiTransfer.bind(this);
  }

  deposit = ({
    user
  }: {
    user: User;
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          deposit: {
            user
          }
        })),
        funds
      })
    };
  };
  withdraw = ({
    amount
  }: {
    amount: Uint128;
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          withdraw: {
            amount
          }
        })),
        funds
      })
    };
  };
  updateConfig = ({
    dappAddressAndDenomList,
    feeDefault,
    feeOsmo,
    scheduler,
    stablecoinDenom,
    stablecoinPoolId
  }: {
    dappAddressAndDenomList?: string[][][];
    feeDefault?: Decimal;
    feeOsmo?: Decimal;
    scheduler?: string;
    stablecoinDenom?: string;
    stablecoinPoolId?: number;
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          update_config: {
            dapp_address_and_denom_list: dappAddressAndDenomList,
            fee_default: feeDefault,
            fee_osmo: feeOsmo,
            scheduler,
            stablecoin_denom: stablecoinDenom,
            stablecoin_pool_id: stablecoinPoolId
          }
        })),
        funds
      })
    };
  };
  updatePoolsAndUsers = ({
    pools,
    users
  }: {
    pools: PoolExtracted[];
    users: UserExtracted[];
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          update_pools_and_users: {
            pools,
            users
          }
        })),
        funds
      })
    };
  };
  swap = (funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          swap: {}
        })),
        funds
      })
    };
  };
  transfer = (funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          transfer: {}
        })),
        funds
      })
    };
  };
  multiTransfer = ({
    params
  }: {
    params: TransferParams[];
  }, funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          multi_transfer: {
            params
          }
        })),
        funds
      })
    };
  };
}